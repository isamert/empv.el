import { parseArgs } from "jsr:@std/cli@^1.0.25/parse-args";
import { join } from "jsr:@std/path@^1.1.4/join";
import {
  Innertube,
  Types as InnerTubeTypes,
  UniversalCache,
} from "npm:youtubei.js@^16.0.1";

// * CLI

const flags = parseArgs(Deno.args, {
  string: ["port", "baseTempDir"],
  default: {
    port: 3467,
  },
});

// * InnerTube

let cache
if (flags.baseTempDir) {
  cache = new UniversalCache(
    true,
    // Path to the cache directory. The directory will be created if it doesn't exist
    join(flags.baseTempDir, "empv-ivjs-cache"),
  )
}
const innertube = await Innertube.create({
  cache,
});

// * Endpoints

// ** Search Suggestion

// *** Types

export type SearchSuggestionsParams = {
  q: string;
};

export type SearchSuggestionsResponse = {
  query: string;
  suggestions: string[];
};

// *** getSearchSuggestions

const getSearchSuggestions = async (
  req: SearchSuggestionsParams,
): Promise<SearchSuggestionsResponse> => {
  const result = await innertube.getSearchSuggestions(req.q);
  return {
    query: req.q,
    suggestions: result,
  };
};

// ** Search

// *** Types

export type SearchParams = {
  q: string;
  // FIXME: Page is *not* utilized
  page?: number;
  sort?: InnerTubeTypes.SortBy;
  date?: InnerTubeTypes.UploadDate;
  duration?: InnerTubeTypes.Duration;
  type?: InnerTubeTypes.SearchType;
  features?: InnerTubeTypes.Feature[];
  // TODO: not supported right now
  region?: string; // ISO 3166 country code
};

export type VideoThumbnail = {
  quality: string;
  url: string;
  width: number;
  height: number;
};

export type AuthorThumbnail = {
  url: string;
  width: number;
  height: number;
};

export type VideoResult = {
  type: "video";
  title: string;
  videoId: string;
  author: string;
  authorId: string;
  authorUrl: string;
  videoThumbnails: VideoThumbnail[];
  description: string;
  descriptionHtml: string;
  viewCount: number;
  viewCountText: number;
  published: number;
  publishedText: string;
  lengthSeconds: number;
  liveNow: boolean;
  paid: boolean;
  premium: boolean;
};

export type PlaylistVideo = {
  title: string;
  videoId: string;
  lengthSeconds: number;
  videoThumbnails: VideoThumbnail[];
};

export type PlaylistResult = {
  type: "playlist";
  title: string;
  playlistId: string;
  playlistThumbnail: string;
  author: string;
  authorId: string;
  authorUrl: string;
  authorVerified: boolean;
  videoCount: number;
  videos: PlaylistVideo[];
};

export type ChannelResult = {
  type: "channel";
  author: string;
  authorId: string;
  authorUrl: string;
  authorThumbnails: AuthorThumbnail[];
  autoGenerated: boolean;
  subCount: number;
  videoCount: number;
  description: string;
  descriptionHtml: string;
};

export type HashtagResult = {
  type: "hashtag";
  title: string;
  url: string;
  channelCount: number;
  videoCount: number;
};

export type SearchResult =
  | VideoResult
  | PlaylistResult
  | ChannelResult
  | HashtagResult;

export type SearchResponse = SearchResult[];

// *** search

const search = async (req: SearchParams): Promise<SearchResponse> => {
  const result = await innertube.search(req.q, {
    upload_date: req.date,
    type: req.type,
    duration: req.duration,
    sort_by: req.sort,
    features: req.features,
  });

  return [...result.playlists, ...result.channels, ...result.videos].map(
    (item) => {
      switch (item.type) {
        case "Video":
          return convertVideo(item);
        case "Playlist":
          return convertPlaylist(item);
        case "Channel":
          return convertChannel(item);
        default:
          return null;
      }
    },
  ).filter((item) => item !== null);
};

// *** Utility
// **** Shared

function textFrom(t: any): string {
  return t?.text ?? t?.runs?.map((r: any) => r.text).join("") ?? "";
}

function parseNumber(s: string | undefined): number {
  if (!s) return 0;
  const match = s.replace(/,/g, "").match(/(\d+(\.\d+)?)/);
  return match ? Number(match[1]) : 0;
}

function parseDuration(s: string | undefined): number {
  if (!s) return 0;
  const parts = s.split(":").map(Number);
  if (parts.some(isNaN)) return 0;

  return parts.reduceRight((acc, val, idx) =>
    acc + val * Math.pow(60, parts.length - 1 - idx), 0
  );
}

function parsePublishedAgo(s: string | undefined): number {
  if (!s) return 0;

  const match = s.match(/(\d+)\s+(second|minute|hour|day|week|month|year)s?\s+ago/i);
  if (!match) return 0;

  const [, numStr, unit] = match;
  const num = Number(numStr);

  const msPerUnit: Record<string, number> = {
    second: 1000,
    minute: 60 * 1000,
    hour: 60 * 60 * 1000,
    day: 24 * 60 * 60 * 1000,
    week: 7 * 24 * 60 * 60 * 1000,
    month: 30 * 24 * 60 * 60 * 1000,
    year: 365 * 24 * 60 * 60 * 1000,
  };

  const ms = msPerUnit[unit.toLowerCase()] * num;
  return Math.floor((Date.now() - ms) / 1000);
}

function htmlEscape(s: string): string {
  const escapeMap: Record<string, string> = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
  };
  return s.replace(/[&<>]/g, (char) => escapeMap[char]);
}

type ThumbnailQuality = "maxresdefault" | "maxres" | "sddefault" | "high" | "medium" | "low" | "default";

function inferThumbnailQuality(thumb: { url: string; width?: number; height?: number }): ThumbnailQuality {
  const { url, width = 0, height = 0 } = thumb;

  // Check URL patterns first
  const urlPatterns: [RegExp, ThumbnailQuality][] = [
    [/maxresdefault/, "maxresdefault"],
    [/maxres/, "maxres"],
    [/sddefault/, "sddefault"],
    [/hqdefault/, "high"],
    [/mqdefault/, "medium"],
    [/default/, "default"],
  ];

  for (const [pattern, quality] of urlPatterns) {
    if (pattern.test(url)) return quality;
  }

  // Fallback to dimensions
  if (width >= 1280 || height >= 720) return "maxres";
  if (width >= 640 || height >= 480) return "high";
  if (width >= 320 || height >= 180) return "medium";
  if (width > 0) return "low";

  return "default";
}

function convertThumbnails(
  thumbnails: any[],
): VideoThumbnail[] {
  return thumbnails.map((thumb) => ({
      url: thumb.url,
      width: thumb.width,
      height: thumb.height,
      quality: inferThumbnailQuality(thumb),
  }));
}

interface AuthorInfo {
  name: string;
  id: string;
  url: string;
  verified?: boolean;
}

function extractAuthorInfo(source: any, fallback?: any): AuthorInfo {
  const author = source?.author ?? source;

  if (typeof author === "string") {
    return {
      name: author,
      id: fallback?.authorId ?? "",
      url: fallback?.authorUrl ?? "",
      verified: false,
    };
  }

  return {
    name: fallback?.author ?? author?.name ?? "",
    id: fallback?.authorId ?? author?.id ?? "",
    url: fallback?.authorUrl ?? author?.url ?? "",
    verified: author?.is_verified || author?.is_verified_artist || false,
  };
}

// **** Converters

export function convertVideo(item: any, authorInfo?: any): VideoResult {
  const title = textFrom(item.title);
  const description = textFrom(item.description_snippet);
  const lengthText = item.length_text?.text as string | undefined;

  const author = extractAuthorInfo(item, authorInfo);

  const videoThumbnails = convertThumbnails(item.thumbnails ?? []);

  const viewCount = parseNumber(item.view_count?.text);
  const viewCountText = item.short_view_count?.text ?? "";
  const publishedText = item.published?.text ?? "";
  const published = parsePublishedAgo(publishedText);
  const lengthSeconds = parseDuration(lengthText);

  const liveNow = item.is_live ?? item.badges?.some((b: any) =>
    /live/i.test(b?.text ?? b?.label ?? "")
  ) ?? false;

  return {
    type: "video",
    title,
    videoId: item.video_id ?? item.endpoint?.payload?.videoId ?? "",
    author: author.name,
    authorId: author.id,
    authorUrl: author.url,
    videoThumbnails,
    description,
    descriptionHtml: htmlEscape(description).replace(/\n/g, "<br>"),
    viewCount,
    viewCountText,
    published,
    publishedText,
    lengthSeconds,
    liveNow,
    paid: false,
    premium: false,
  };
}

function convertPlaylist(playlist: any): PlaylistResult {
  const videos: PlaylistVideo[] = (playlist.first_videos || []).map((vid: any) => ({
    title: textFrom(vid.title),
    videoId: vid.video_id || "",
    lengthSeconds: vid.duration?.seconds || 0,
    videoThumbnails: convertThumbnails(vid.thumbnails || []),
  }));

  const author = extractAuthorInfo(playlist);

  return {
    type: "playlist",
    title: textFrom(playlist.title),
    playlistId: playlist.id,
    playlistThumbnail: playlist.thumbnails?.[0]?.url || "",
    author: author.name,
    authorId: author.id,
    authorUrl: author.url,
    authorVerified: author.verified ?? false,
    videoCount: parseNumber(playlist.video_count?.text),
    videos,
  };
}

function convertChannel(channel: any): ChannelResult {
  const author = extractAuthorInfo(channel);
  const description = textFrom(channel.description_snippet);

  return {
    type: "channel",
    author: author.name,
    authorId: channel.id,
    authorUrl: author.url,
    authorThumbnails: convertThumbnails(channel.author?.thumbnails || []),
    autoGenerated: false,
    subCount: parseNumber(channel.subscriber_count?.text),
    videoCount: parseNumber(channel.video_count?.text),
    description,
    descriptionHtml: description,
  };
}

// ** Channel videos
// *** Types

type ChannelVideosResult = {
  videos: VideoResult[];
  continuation: string;
};

type ChannelVideosParams = {
  sort_by: ("newest" | "latest") | "popular" | "oldest";
  continuation: string;
};

// *** getChannelVideos

const getChannelVideos = async (
  id: string,
  req: ChannelVideosParams,
): Promise<ChannelVideosResult> => {
  const sortBy = req.sort_by
    ? (req.sort_by === "newest" ? "latest" : req.sort_by)
    : "latest";

  const channel = await innertube.getChannel(id);
  const channelVideos = await channel.getVideos();
  const sortFilter = channelVideos.filters.find((x) =>
    x.toLowerCase() === sortBy
  )!;
  const response = await channelVideos.applyFilter(sortFilter);

  let continuation: string = ""; // TODO: No continuation...
  const metadata = channelVideos?.metadata ?? {};
  const author = metadata.title ?? "";
  const authorId = metadata.external_id ?? "";
  const authorUrl = metadata.url ?? "";
  const authorInfo = { author, authorId, authorUrl };

  return {
    videos: response?.videos?.filter((item) => item?.type === "Video").map(video => convertVideo(video, authorInfo)),
    continuation,
  };
};

// ** Comments
// *** Types

type CommentsParams = {
  sort_by: "top" | "new";
  source: "youtube";
};

type CommentsResponse = {
  commentCount?: number | null;
  videoId: string;
  comments: CommentThread[];
  continuation?: string | null;
};

type CommentThread = {
  author: string;
  authorThumbnails: AuthorThumbnail[];
  authorId: string;
  authorUrl: string;

  isEdited: boolean;
  isPinned: boolean;
  isSponsor?: boolean | null;
  sponsorIconUrl?: string | null;

  content: string;
  contentHtml: string;
  published: number; // Int64
  publishedText: string;
  likeCount: number;
  commentId: string;
  authorIsChannelOwner: boolean;

  creatorHeart?: CreatorHeart | null;
  replies?: CommentReplies | null;
};

type CreatorHeart = {
  creatorThumbnail: string;
  creatorName: string;
};

type CommentReplies = {
  replyCount: number;
  continuation: string;
};

// *** getVideoComments

const getVideoComments = async (
  id: string,
  params: CommentsParams,
): Promise<CommentsResponse> => {
  const sortBy = params.sort_by === "new"
    ? "NEWEST_FIRST"
    : params.sort_by === "top"
    ? "TOP_COMMENTS"
    : undefined;

  let commentsResponse = await innertube.getComments(id);
  if (sortBy) {
    commentsResponse = await commentsResponse.applySort(sortBy);
  }

  const parseLikeCount = (raw?: string): number => {
    if (!raw) return 0;
    const n = Number(raw.replace(/[^\d]/g, ""));
    return Number.isFinite(n) ? n : 0;
  };

  const toThumbnails = (author: any): AuthorThumbnail[] => {
    return (author?.thumbnails ?? []).map((t: any) => ({
      url: t.url,
      width: t.width,
      height: t.height,
    }));
  };

  const toCreatorHeart = (c: any): CreatorHeart | undefined => {
    if (!c?.is_hearted) return undefined;

    const m = String(c.heart_active_tooltip).match(/by\s+(.+)$/i);
    const creatorName = m ? m[1] : undefined;

    if (!creatorName || !c.creator_thumbnail_url) return undefined;

    return {
      creatorName,
      creatorThumbnail: c.creator_thumbnail_url,
    };
  };

  const toReplies = (commentThread: any): CommentReplies | undefined => {
    const replyCount = parseLikeCount(commentThread?.comment?.reply_count);
    if (!replyCount) return undefined;

    return {
      replyCount,
      // TODO: continuation
      continuation: "NULL",
    };
  };

  const toInvidiousComment = (thread: any): CommentThread => {
    const c = thread.comment;

    const author = c.author;

    const authorName: string = author?.name ??
      (typeof c.author === "string" ? c.author : "");

    const authorId: string = author?.id ??
      author?.channel_id ??
      "";

    const authorUrl: string = author?.url ??
      author?.endpoint?.metadata?.url ??
      "";

    const isSponsor: boolean | undefined = typeof c.is_member === "boolean"
      ? c.is_member
      : undefined;

    const likeCount = parseLikeCount(c.like_count);
    const replyData = toReplies(thread);
    const creatorHeart = toCreatorHeart(c);

    return {
      author: authorName,
      authorThumbnails: toThumbnails(author),
      authorId,
      authorUrl,

      isEdited: false, // TODO: Check an edited comment for this.
      isPinned: Boolean(c.is_pinned),
      isSponsor,

      sponsorIconUrl: undefined,

      content: c.content?.text ?? "",
      contentHtml: c.content?.text ?? "",
      published: 0, // TODO: Parse this from publishedText?
      publishedText: c.published_time ?? "",

      likeCount,
      commentId: c.comment_id,
      authorIsChannelOwner: Boolean(c.author_is_channel_owner),

      creatorHeart,
      replies: replyData,
    };
  };

  const comments = commentsResponse.contents
    .filter((t) => t?.comment)
    .map(toInvidiousComment);

  return {
    videoId: id,
    commentCount: Number(commentsResponse.header?.comments_count.text) ??
      comments.length,
    comments,
    // TODO: continuation
    continuation: "NULL",
  };
};

// ** Get Video
// *** Types

export type Storyboard = {
  url: string;
  templateUrl: string;
  width: number;
  height: number;
  count: number;
  interval: number;
  storyboardWidth: number;
  storyboardHeight: number;
  storyboardCount: number;
};

export type AdaptiveFormat = {
  index: string;
  bitrate: string;
  init: string;
  url: string;
  itag: string;
  type: string;
  clen: string;
  lmt: string;
  projectionType: string;
  container: string;
  encoding: string;
  qualityLabel?: string;
  resolution?: string;
  fps: number;
  size?: string;
  targetDurationSec?: number;
  maxDvrDurationSec?: number;
  audioQuality?: string;
  audioSampleRate?: string;
  audioChannels?: string;
  colorInfo?: string;
  captionTrack?: string;
};

export type FormatStream = {
  url: string;
  itag: string;
  type: string;
  quality: string;
  bitrate?: string;
  container: string;
  encoding: string;
  qualityLabel: string;
  resolution: string;
  size: string;
};

export type Caption = {
  label: string;
  language_code: string;
  url: string;
};

export type MusicTrack = {
  song: string;
  artist: string;
  album: string;
  license: string;
};

export type RecommendedVideo = {
  videoId: string;
  title: string;
  videoThumbnails: VideoThumbnail[];
  author: string;
  authorUrl: string;
  authorId?: string;
  authorVerified: boolean;
  authorThumbnails: AuthorThumbnail[];
  lengthSeconds: number;
  viewCount: number;
  viewCountText: string;
};

export type SingleVideoResponse = {
  type: "video";
  title: string;
  videoId: string;
  videoThumbnails: VideoThumbnail[];
  storyboards: Storyboard[];
  description: string;
  descriptionHtml: string;
  published: number;
  publishedText: string;
  keywords: string[];
  viewCount: number;
  likeCount: number;
  dislikeCount: number;
  paid: boolean;
  premium: boolean;
  isFamilyFriendly: boolean;
  allowedRegions: string[];
  genre: string;
  genreUrl: string;
  author: string;
  authorId: string;
  authorUrl: string;
  authorThumbnails: AuthorThumbnail[];
  subCountText: string;
  lengthSeconds: number;
  allowRatings: boolean;
  rating: number;
  isListed: boolean;
  liveNow: boolean;
  isPostLiveDvr: boolean;
  isUpcoming: boolean;
  dashUrl: string;
  premiereTimestamp?: number;
  hlsUrl?: string;
  adaptiveFormats: AdaptiveFormat[];
  formatStreams: FormatStream[];
  captions: Caption[];
  musicTracks: MusicTrack[];
  recommendedVideos: RecommendedVideo[];
};

// *** getVideo

const getVideo = async (id: string): Promise<SingleVideoResponse> => {
  const response = await innertube.getBasicInfo(id);

  const basicInfo = response.basic_info ?? {};
  const streamingData = response.streaming_data ?? {};
  const storyboardsData = response.storyboards?.boards ?? [];
  const authorInfo = extractAuthorInfo(basicInfo);

  function extractContainer(mimeType: string): string {
    const match = mimeType?.match(/^(video|audio)\/([^;]+)/);
    return match?.[2] ?? "";
  }

  function extractEncoding(mimeType: string): string {
    const match = mimeType?.match(/codecs="([^"]+)"/);
    return match?.[1]?.split(",")[0]?.trim() ?? "";
  }

  function formatResolution(width?: number, height?: number): string {
    if (width && height) return `${width}x${height}`;
    return "";
  }

  const storyboards: Storyboard[] = storyboardsData
    .filter((b: any) => b.interval > 0)
    .map((board: any) => ({
      url: board.template_url?.replace("M$M", "0") ?? "",
      templateUrl: board.template_url ?? "",
      width: board.thumbnail_width ?? 0,
      height: board.thumbnail_height ?? 0,
      count: board.thumbnail_count ?? 0,
      interval: board.interval ?? 0,
      storyboardWidth: board.columns ?? 0,
      storyboardHeight: board.rows ?? 0,
      storyboardCount: board.storyboard_count ?? 0,
    }));

  const adaptiveFormats: AdaptiveFormat[] = (streamingData.adaptive_formats ?? []).map((fmt: any) => ({
    index: fmt.index_range ? `${fmt.index_range.start}-${fmt.index_range.end}` : "",
    bitrate: String(fmt.bitrate ?? ""),
    init: fmt.init_range ? `${fmt.init_range.start}-${fmt.init_range.end}` : "",
    url: fmt.url ?? "",
    itag: String(fmt.itag ?? ""),
    type: fmt.mime_type ?? "",
    clen: String(fmt.content_length ?? ""),
    lmt: String(fmt.last_modified_ms ?? ""),
    projectionType: fmt.projection_type ?? "",
    container: extractContainer(fmt.mime_type ?? ""),
    encoding: extractEncoding(fmt.mime_type ?? ""),
    qualityLabel: fmt.quality_label,
    resolution: fmt.width && fmt.height ? formatResolution(fmt.width, fmt.height) : undefined,
    fps: fmt.fps ?? 0,
    size: fmt.width && fmt.height ? formatResolution(fmt.width, fmt.height) : undefined,
    audioQuality: fmt.audio_quality,
    audioSampleRate: fmt.audio_sample_rate ? String(fmt.audio_sample_rate) : undefined,
    audioChannels: fmt.audio_channels ? String(fmt.audio_channels) : undefined,
  }));

  const formatStreams: FormatStream[] = (streamingData.formats ?? []).map((fmt: any) => ({
    url: fmt.url ?? "",
    itag: String(fmt.itag ?? ""),
    type: fmt.mime_type ?? "",
    quality: fmt.quality ?? "",
    bitrate: fmt.bitrate ? String(fmt.bitrate) : undefined,
    container: extractContainer(fmt.mime_type ?? ""),
    encoding: extractEncoding(fmt.mime_type ?? ""),
    qualityLabel: fmt.quality_label ?? "",
    resolution: formatResolution(fmt.width, fmt.height),
    size: formatResolution(fmt.width, fmt.height),
  }));

  const description = basicInfo.short_description ?? "";

  return {
    type: "video",
    title: basicInfo.title ?? "",
    videoId: basicInfo.id ?? "",
    videoThumbnails: convertThumbnails(basicInfo.thumbnail ?? []),
    storyboards,
    description,
    descriptionHtml: htmlEscape(description),
    published: 0,
    publishedText: "",
    keywords: basicInfo.tags ?? [],
    viewCount: basicInfo.view_count ?? 0,
    likeCount: 0,
    dislikeCount: 0,
    paid: false,
    premium: false,
    isFamilyFriendly: basicInfo.is_family_safe ?? true,
    allowedRegions: [],
    genre: basicInfo.category ?? "",
    genreUrl: "",
    author: authorInfo.name,
    authorId: authorInfo.id,
    authorUrl: authorInfo.url,
    authorThumbnails: [],
    subCountText: "",
    lengthSeconds: basicInfo.duration ?? 0,
    allowRatings: basicInfo.allow_ratings ?? true,
    rating: 0,
    isListed: !basicInfo.is_unlisted,
    liveNow: basicInfo.is_live ?? false,
    isPostLiveDvr: basicInfo.is_post_live_dvr ?? false,
    isUpcoming: basicInfo.is_upcoming ?? false,
    dashUrl: "",
    premiereTimestamp: undefined,
    hlsUrl: undefined,
    adaptiveFormats,
    formatStreams,
    captions: [],
    musicTracks: [],
    recommendedVideos: [],
  };
};

// * Server

Deno.serve({ port: Number(flags.port) }, async (req) => {
  const url = new URL(req.url);
  const searchParams: any = Object.fromEntries(url.searchParams);

  console.log("→", { url: req.url });

  const routes: [string, (params?: any) => Promise<string | object>][] = [
    [
      "/ping",
      () => Promise.resolve("pong"),
    ],
    [
      "/api/v1/search/suggestions",
      () => getSearchSuggestions(searchParams),
    ],
    [
      "/api/v1/search",
      () => search(searchParams),
    ],
    [
      "/api/v1/videos/(?<videoId>[a-zA-Z0-9_-]+)",
      (params: any) => getVideo(params.videoId),
    ],
    [
      "/api/v1/channels/(?<channelId>[a-zA-Z0-9_-]+)/videos",
      (params: any) => getChannelVideos(params.channelId, searchParams),
    ],
    [
      "/api/v1/comments/(?<videoId>[a-zA-Z0-9_-]+)",
      (params: any) => getVideoComments(params.videoId, searchParams),
    ],
  ];

  let response;
  for (const [pattern, handler] of routes) {
    const match = RegExp(pattern).exec(url.pathname);
    if (match) {
      const result = await handler(match.groups || {});
      if (result) {
        response = result;
        break;
      }
    }
  }

  console.log("←", response ? "OK" : undefined);

  if (response) {
    return typeof response === "string"
      ? new Response(response)
      : new Response(JSON.stringify(response));
  }

  return new Response(`Not found`, { status: 404 });
});
