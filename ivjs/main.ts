import { parseArgs } from "jsr:@std/cli/parse-args";
import {
  Innertube,
  Types as InnerTubeTypes,
  UniversalCache,
} from "youtubei.js";

// * InnerTube

const innertube = await Innertube.create({
  cache: new UniversalCache(
    // Enables persistent caching
    true,
    // Path to the cache directory. The directory will be created if it doesn't exist
    "./.cache",
  ),
});

// * Endpoints

// ** Search Suggestion

// *** Types

export type SearchSuggestionsParams = {
  q: string;
};

export type SearchSuggestionsResponse = {
  query: string;
  suggestions: string[];
};

// *** getSearchSuggestions

const getSearchSuggestions = async (
  req: SearchSuggestionsParams,
): Promise<SearchSuggestionsResponse> => {
  const result = await innertube.getSearchSuggestions(req.q);
  return {
    query: req.q,
    suggestions: result,
  };
};

// ** Search

// *** Types

export type SearchParams = {
  q: string;
  // FIXME: Page is utilized
  page?: number;
  sort?: InnerTubeTypes.SortBy;
  date?: InnerTubeTypes.UploadDate;
  duration?: InnerTubeTypes.Duration;
  type?: InnerTubeTypes.SearchType;
  features?: InnerTubeTypes.Feature[];
  // TODO: not supported right now
  region?: string; // ISO 3166 country code
};

export type VideoThumbnail = {
  quality: string;
  url: string;
  width: number;
  height: number;
};

export type AuthorThumbnail = {
  url: string;
  width: number;
  height: number;
};

export type VideoResult = {
  type: "video";
  title: string;
  videoId: string;
  author: string;
  authorId: string;
  authorUrl: string;
  videoThumbnails: VideoThumbnail[];
  description: string;
  descriptionHtml: string;
  viewCount: number;
  viewCountText: number;
  published: number;
  publishedText: string;
  lengthSeconds: number;
  liveNow: boolean;
  paid: boolean;
  premium: boolean;
};

export type PlaylistVideo = {
  title: string;
  videoId: string;
  lengthSeconds: number;
  videoThumbnails: VideoThumbnail[];
};

export type PlaylistResult = {
  type: "playlist";
  title: string;
  playlistId: string;
  playlistThumbnail: string;
  author: string;
  authorId: string;
  authorUrl: string;
  authorVerified: boolean;
  videoCount: number;
  videos: PlaylistVideo[];
};

export type ChannelResult = {
  type: "channel";
  author: string;
  authorId: string;
  authorUrl: string;
  authorThumbnails: AuthorThumbnail[];
  autoGenerated: boolean;
  subCount: number;
  videoCount: number;
  description: string;
  descriptionHtml: string;
};

export type HashtagResult = {
  type: "hashtag";
  title: string;
  url: string;
  channelCount: number;
  videoCount: number;
};

export type SearchResult =
  | VideoResult
  | PlaylistResult
  | ChannelResult
  | HashtagResult;

export type SearchResponse = SearchResult[];

// *** search result mapper (mostly generated by claude)

/**
 * Converts YouTube search results to the target format
 * @param {unknown} result - The YouTube search result object
 * @returns {Array<{type: string, [key: string]: unknown}>} Converted results
 */
function convertYouTubeResults(result) {
  if (!result || typeof result !== "object" || !("results" in result)) {
    return [];
  }

  const results = result.results;
  if (!Array.isArray(results)) {
    return [];
  }

  return results.map((item) => {
    if (!item || typeof item !== "object" || !("type" in item)) {
      return null;
    }

    switch (item.type) {
      case "Video":
        return convertVideo(item);
      case "Playlist":
        return convertPlaylist(item);
      case "Channel":
        return convertChannel(item);
      case "Hashtag":
        return convertHashtag(item);
      default:
        return null;
    }
  }).filter((item) => item !== null);
}

/**
 * Converts a video item
 * @param {Record<string, unknown>} item
 * @returns {{type: string, [key: string]: unknown}}
 */
function convertVideo(item) {
  const title = getText(item.title);
  const videoId = typeof item.video_id === "string" ? item.video_id : "";

  const author = item.author && typeof item.author === "object"
    ? (typeof item.author.name === "string" ? item.author.name : "")
    : "";

  const authorId = item.author && typeof item.author === "object"
    ? (typeof item.author.id === "string" ? item.author.id : "")
    : "";

  const authorUrl = item.author && typeof item.author === "object"
    ? (typeof item.author.url === "string" ? item.author.url : "")
    : "";

  const videoThumbnails = convertThumbnails(item.thumbnails);

  const description = getSnippetText(item.snippets);
  const descriptionHtml = getSnippetHtml(item.snippets);

  const viewCount = parseViewCount(item.view_count);
  const viewCountText = getText(item.view_count);

  const published = 0; // Not available in timestamp format
  const publishedText = getText(item.published);

  const lengthSeconds = parseLengthSeconds(item.length_text);

  const liveNow = false; // Could check badges for LIVE badge
  const paid = false;
  const premium = false;

  return {
    type: "video",
    title,
    videoId,
    author,
    authorId,
    authorUrl,
    videoThumbnails,
    description,
    descriptionHtml,
    viewCount,
    viewCountText,
    published,
    publishedText,
    lengthSeconds,
    liveNow,
    paid,
    premium,
  };
}

/**
 * Converts a playlist item
 * @param {Record<string, unknown>} item
 * @returns {{type: string, [key: string]: unknown}}
 */
function convertPlaylist(item) {
  const title = getText(item.title);
  const playlistId = typeof item.playlist_id === "string"
    ? item.playlist_id
    : "";

  const thumbnails =
    Array.isArray(item.thumbnails) && item.thumbnails.length > 0
      ? item.thumbnails[0]
      : null;
  const playlistThumbnail =
    thumbnails && typeof thumbnails === "object" && "url" in thumbnails
      ? ensureHttps(typeof thumbnails.url === "string" ? thumbnails.url : "")
      : "";

  const author = item.author && typeof item.author === "object"
    ? (typeof item.author.name === "string" ? item.author.name : "")
    : "";

  const authorId = item.author && typeof item.author === "object"
    ? (typeof item.author.id === "string" ? item.author.id : "")
    : "";

  const authorUrl = item.author && typeof item.author === "object"
    ? (typeof item.author.url === "string" ? item.author.url : "")
    : "";

  const authorVerified = item.author && typeof item.author === "object" &&
      "is_verified" in item.author
    ? Boolean(item.author.is_verified || item.author.is_verified_artist)
    : false;

  const videoCount = typeof item.video_count === "number"
    ? item.video_count
    : 0;

  const videos = Array.isArray(item.videos)
    ? item.videos.map(convertPlaylistVideo).filter((v) => v !== null)
    : [];

  return {
    type: "playlist",
    title,
    playlistId,
    playlistThumbnail,
    author,
    authorId,
    authorUrl,
    authorVerified,
    videoCount,
    videos,
  };
}

/**
 * Converts a playlist video item
 * @param {unknown} video
 * @returns {{title: string, videoId: string, lengthSeconds: number, videoThumbnails: Array<{quality: string, url: string, width: number, height: number}>} | null}
 */
function convertPlaylistVideo(video) {
  if (!video || typeof video !== "object") {
    return null;
  }

  const title = "title" in video ? getText(video.title) : "";
  const videoId = "video_id" in video && typeof video.video_id === "string"
    ? video.video_id
    : "";
  const lengthSeconds = "length_text" in video
    ? parseLengthSeconds(video.length_text)
    : 0;
  const videoThumbnails = "thumbnails" in video
    ? convertThumbnails(video.thumbnails)
    : [];

  return {
    title,
    videoId,
    lengthSeconds,
    videoThumbnails,
  };
}

/**
 * Converts a channel item
 * @param {Record<string, unknown>} item
 * @returns {{type: string, [key: string]: unknown}}
 */
function convertChannel(item) {
  const author = item.author && typeof item.author === "object"
    ? (typeof item.author.name === "string" ? item.author.name : "")
    : "";

  const authorId = typeof item.id === "string" ? item.id : "";

  const authorUrl = item.author && typeof item.author === "object"
    ? (typeof item.author.url === "string" ? item.author.url : "")
    : "";

  const authorThumbnails = item.author && typeof item.author === "object" &&
      "thumbnails" in item.author
    ? convertThumbnails(item.author.thumbnails)
    : [];

  const autoGenerated = false;

  const subCount = parseSubscriberCount(item.video_count);

  const videoCount = 0; // subscriber_count field seems misnamed in source

  const description = getText(item.description_snippet);
  const descriptionHtml = getTextAsHtml(item.description_snippet);

  return {
    type: "channel",
    author,
    authorId,
    authorUrl,
    authorThumbnails,
    autoGenerated,
    subCount,
    videoCount,
    description,
    descriptionHtml,
  };
}

/**
 * Converts a hashtag item
 * @param {Record<string, unknown>} item
 * @returns {{type: string, [key: string]: unknown}}
 */
function convertHashtag(item) {
  const title = getText(item.title);
  const url = typeof item.url === "string" ? item.url : "";
  const channelCount = typeof item.channel_count === "number"
    ? item.channel_count
    : 0;
  const videoCount = typeof item.video_count === "number"
    ? item.video_count
    : 0;

  return {
    type: "hashtag",
    title,
    url,
    channelCount,
    videoCount,
  };
}

/**
 * Extracts text from a text object
 * @param {unknown} textObj
 * @returns {string}
 */
function getText(textObj) {
  if (!textObj || typeof textObj !== "object") {
    return "";
  }

  if ("text" in textObj && typeof textObj.text === "string") {
    return textObj.text;
  }

  return "";
}

/**
 * Gets snippet text
 * @param {unknown} snippets
 * @returns {string}
 */
function getSnippetText(snippets) {
  if (!Array.isArray(snippets) || snippets.length === 0) {
    return "";
  }

  const firstSnippet = snippets[0];
  if (
    !firstSnippet || typeof firstSnippet !== "object" ||
    !("text" in firstSnippet)
  ) {
    return "";
  }

  return getText(firstSnippet.text);
}

/**
 * Gets snippet HTML
 * @param {unknown} snippets
 * @returns {string}
 */
function getSnippetHtml(snippets) {
  if (!Array.isArray(snippets) || snippets.length === 0) {
    return "";
  }

  const firstSnippet = snippets[0];
  if (
    !firstSnippet || typeof firstSnippet !== "object" ||
    !("text" in firstSnippet)
  ) {
    return "";
  }

  return getTextAsHtml(firstSnippet.text);
}

/**
 * Converts text object to HTML
 * @param {unknown} textObj
 * @returns {string}
 */
function getTextAsHtml(textObj) {
  if (!textObj || typeof textObj !== "object" || !("runs" in textObj)) {
    return getText(textObj);
  }

  const runs = textObj.runs;
  if (!Array.isArray(runs)) {
    return getText(textObj);
  }

  return runs.map((run) => {
    if (
      !run || typeof run !== "object" || !("text" in run) ||
      typeof run.text !== "string"
    ) {
      return "";
    }

    let html = run.text;

    if ("bold" in run && run.bold === true) {
      html = `<b>${html}</b>`;
    }

    return html;
  }).join("");
}

/**
 * Converts thumbnails array
 * @param {unknown} thumbnails
 * @returns {Array<{quality: string, url: string, width: number, height: number}>}
 */
function convertThumbnails(thumbnails) {
  if (!Array.isArray(thumbnails)) {
    return [];
  }

  return thumbnails.map((thumb, index) => {
    if (!thumb || typeof thumb !== "object") {
      return null;
    }

    const url = "url" in thumb && typeof thumb.url === "string"
      ? ensureHttps(thumb.url)
      : "";
    const width = "width" in thumb && typeof thumb.width === "number"
      ? thumb.width
      : 0;
    const height = "height" in thumb && typeof thumb.height === "number"
      ? thumb.height
      : 0;

    const quality = getQualityFromDimensions(width, height, index);

    return { quality, url, width, height };
  }).filter((thumb) => thumb !== null);
}

/**
 * Gets quality string from dimensions
 * @param {number} width
 * @param {number} height
 * @param {number} index
 * @returns {string}
 */
function getQualityFromDimensions(width, height, index) {
  if (height >= 720 || width >= 1280) return "high";
  if (height >= 360 || width >= 640) return "medium";
  if (height >= 180 || width >= 320) return "low";
  return `thumbnail${index}`;
}

/**
 * Ensures URL has https protocol
 * @param {string} url
 * @returns {string}
 */
function ensureHttps(url) {
  if (url.startsWith("//")) {
    return `https:${url}`;
  }
  return url;
}

/**
 * Parses view count from text
 * @param {unknown} viewCountObj
 * @returns {number}
 */
function parseViewCount(viewCountObj) {
  const text = getText(viewCountObj);
  if (!text) return 0;

  const match = text.match(/[\d,]+/);
  if (!match) return 0;

  return parseInt(match[0].replace(/,/g, ""), 10) || 0;
}

/**
 * Parses subscriber count from text
 * @param {unknown} subCountObj
 * @returns {number}
 */
function parseSubscriberCount(subCountObj) {
  const text = getText(subCountObj);
  if (!text) return 0;

  const match = text.match(/([\d.]+)([KMB]?)/i);
  if (!match) return 0;

  const num = parseFloat(match[1]);
  const multiplier = match[2].toUpperCase();

  switch (multiplier) {
    case "K":
      return Math.floor(num * 1000);
    case "M":
      return Math.floor(num * 1000000);
    case "B":
      return Math.floor(num * 1000000000);
    default:
      return Math.floor(num);
  }
}

/**
 * Parses length in seconds from time string
 * @param {unknown} lengthObj
 * @returns {number}
 */
function parseLengthSeconds(lengthObj) {
  const text = getText(lengthObj);
  if (!text) return 0;

  const parts = text.split(":").map((p) => parseInt(p, 10));
  if (parts.some(isNaN)) return 0;

  if (parts.length === 2) {
    return parts[0] * 60 + parts[1];
  } else if (parts.length === 3) {
    return parts[0] * 3600 + parts[1] * 60 + parts[2];
  }

  return 0;
}

// *** search

const search = async (req: SearchParams): Promise<SearchResponse> => {
  const result = await innertube.search(req.q, {
    upload_date: req.date,
    type: req.type,
    duration: req.duration,
    sort_by: req.sort,
    features: req.features,
  });

  result.getContinuationData();

  return convertYouTubeResults(result);
};

// ** Channel videos
// *** Types

type ChannelVideosResult = {
  videos: VideoResult[];
  continuation: string;
};

type ChannelVideosParams = {
  sort_by: ("newest" | "latest") | "popular" | "oldest";
  continuation: string;
};

// *** getChannelVideos

const getChannelVideos = async (
  id: string,
  req: ChannelVideosParams,
): Promise<ChannelVideosResult> => {
  const sortBy = req.sort_by
    ? (req.sort_by === "newest" ? "latest" : req.sort_by)
    : "latest";

  const channel = await innertube.getChannel(id);
  const channelVideos = await channel.getVideos();
  const sortFilter = channelVideos.filters.find((x) =>
    x.toLowerCase() === sortBy
  )!;
  const response = await channelVideos.applyFilter(sortFilter);

  let continuation: string = "";
  if (channelVideos.has_continuation) {
    continuation = encodePage(response.page);
  }
  const metadata = channelVideos?.metadata ?? {};
  const author = metadata.title ?? "";
  const authorId = metadata.external_id ?? "";
  const authorUrl = metadata.url ?? "";
  const authorInfo = { author, authorId, authorUrl };

  return {
    videos: channelVideosToVideoResult(response?.videos, authorInfo),
    continuation,
  };
};

export function channelVideosToVideoResult(
  raw: any[],
  authorInfo: any,
): VideoResult[] {
  const textFrom = (t: any): string =>
    t?.text ?? t?.runs?.map((r: any) => r.text).join("") ?? "";

  const parseNumber = (s: string | undefined): number => {
    if (!s) return 0;
    // "126,020,980 views" -> 126020980
    const m = s.replace(/,/g, "").match(/(\d+(\.\d+)?)/);
    if (!m) return 0;
    return Number(m[1]);
  };

  const parsePublishedAgo = (s: string | undefined): number => {
    // very rough: "10 years ago" -> timestamp
    if (!s) return 0;
    const m = s.match(
      /(\d+)\s+(second|minute|hour|day|week|month|year)s?\s+ago/i,
    );
    if (!m) return 0;
    const num = Number(m[1]);
    const unit = m[2].toLowerCase();
    const now = Date.now();
    const msPer = {
      second: 1000,
      minute: 60 * 1000,
      hour: 60 * 60 * 1000,
      day: 24 * 60 * 60 * 1000,
      week: 7 * 24 * 60 * 60 * 1000,
      month: 30 * 24 * 60 * 60 * 1000,
      year: 365 * 24 * 60 * 60 * 1000,
    } as const;
    const ms = msPer[unit] * num;
    return Math.floor((now - ms) / 1000); // unix seconds
  };

  const parseDuration = (s: string | undefined): number => {
    // "4:24" | "1:02:03"
    if (!s) return 0;
    const parts = s.split(":").map(Number);
    if (parts.some(isNaN)) return 0;
    if (parts.length === 3) {
      return parts[0] * 3600 + parts[1] * 60 + parts[2];
    }
    if (parts.length === 2) {
      return parts[0] * 60 + parts[1];
    }
    return parts[0] || 0;
  };

  const htmlEscape = (s: string): string =>
    s
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");

  const inferThumbnailQuality = (url: string): VideoThumbnail["quality"] => {
    if (!url) return "default";

    // Common YouTube patterns
    if (url.includes("maxresdefault")) return "maxresdefault";
    if (url.includes("maxres")) return "maxres";
    if (url.includes("sddefault")) return "sddefault";
    if (url.includes("hqdefault")) return "high";
    if (url.includes("mqdefault")) return "medium";
    if (url.includes("default")) return "default";

    // Heuristic by size, fallback
    const m = url.match(/\/(\d+)x(\d+)\./);
    if (m) {
      const w = Number(m[1]);
      const h = Number(m[2]);
      if (w >= 1280 || h >= 720) return "maxres";
      if (w >= 640 || h >= 480) return "high";
      if (w >= 320 || h >= 180) return "medium";
    }

    return "default";
  };

  return raw
    .filter((item) => item?.type === "Video")
    .map((item): VideoResult => {
      const title = textFrom(item.title);
      const description = textFrom(item.description_snippet);
      const lengthText = item.length_text?.text as string | undefined;

      const videoThumbnails: VideoThumbnail[] = (item.thumbnails ?? []).map(
        (t: any): VideoThumbnail => ({
          quality: inferThumbnailQuality(t.url),
          url: t.url,
          width: t.width,
          height: t.height,
        }),
      );

      const authorName = authorInfo.author ?? item.author?.name ?? "";
      const authorId = authorInfo.authorId ?? item.author?.id ?? "";
      const authorUrl = authorInfo.authorUrl ?? item.author?.url ?? "";

      const viewCount = parseNumber(item.view_count?.text);
      const viewCountText = item.short_view_count?.text ?? "";
      const publishedText = item.published?.text ?? "";
      const published = parsePublishedAgo(publishedText);
      const lengthSeconds = parseDuration(lengthText);

      // naive detection; refine as needed
      const liveNow = item.badges?.some((b: any) =>
        /live/i.test(b?.text ?? b?.label ?? "")
      ) ??
        false;

      return {
        type: "video",
        title,
        videoId: item.video_id ?? item.endpoint?.payload?.videoId ?? "",
        author: authorName,
        authorId,
        authorUrl,
        videoThumbnails,
        description,
        descriptionHtml: htmlEscape(description).replace(/\n/g, "<br>"),
        viewCount,
        viewCountText,
        published,
        publishedText,
        lengthSeconds,
        liveNow,
        paid: false,
        premium: false,
      };
    });
}

// ** Comments
// *** Types

type CommentsParams = {
  sort_by: "top" | "new";
  source: "youtube";
};

type CommentsResponse = {
  commentCount?: number | null;
  videoId: string;
  comments: CommentThread[];
  continuation?: string | null;
};

type CommentThread = {
  author: string;
  authorThumbnails: AuthorThumbnail[];
  authorId: string;
  authorUrl: string;

  isEdited: boolean;
  isPinned: boolean;
  isSponsor?: boolean | null;
  sponsorIconUrl?: string | null;

  content: string;
  contentHtml: string;
  published: number; // Int64
  publishedText: string;
  likeCount: number;
  commentId: string;
  authorIsChannelOwner: boolean;

  creatorHeart?: CreatorHeart | null;
  replies?: CommentReplies | null;
};

type CreatorHeart = {
  creatorThumbnail: string;
  creatorName: string;
};

type CommentReplies = {
  replyCount: number;
  continuation: string;
};

// *** getVideoComments

const getVideoComments = async (
  id: string,
  params: CommentsParams,
): Promise<CommentsResponse> => {
  const sortBy = params.sort_by === "new"
    ? "NEWEST_FIRST"
    : params.sort_by === "top"
    ? "TOP_COMMENTS"
    : undefined;

  let commentsResponse = await innertube.getComments(id);
  if (sortBy) {
    commentsResponse = await commentsResponse.applySort(sortBy);
  }

  const parseLikeCount = (raw?: string): number => {
    if (!raw) return 0;
    const n = Number(raw.replace(/[^\d]/g, ""));
    return Number.isFinite(n) ? n : 0;
  };

  const toThumbnails = (author: any): AuthorThumbnail[] => {
    return (author?.thumbnails ?? []).map((t: any) => ({
      url: t.url,
      width: t.width,
      height: t.height,
    }));
  };

  const toCreatorHeart = (c: any): CreatorHeart | undefined => {
    if (!c?.is_hearted) return undefined;

    const m = String(c.heart_active_tooltip).match(/by\s+(.+)$/i);
    const creatorName = m ? m[1] : undefined;

    if (!creatorName || !c.creator_thumbnail_url) return undefined;

    return {
      creatorName,
      creatorThumbnail: c.creator_thumbnail_url,
    };
  };

  const toReplies = (commentThread: any): CommentReplies | undefined => {
    const replyCount = parseLikeCount(commentThread?.comment?.reply_count);
    if (!replyCount) return undefined;

    return {
      replyCount,
      // TODO: continuation
      continuation: "NULL",
    };
  };

  const toInvidiousComment = (thread: any): CommentThread => {
    const c = thread.comment;

    const author = c.author;

    const authorName: string = author?.name ??
      (typeof c.author === "string" ? c.author : "");

    const authorId: string = author?.id ??
      author?.channel_id ??
      "";

    const authorUrl: string = author?.url ??
      author?.endpoint?.metadata?.url ??
      "";

    const isSponsor: boolean | undefined = typeof c.is_member === "boolean"
      ? c.is_member
      : undefined;

    const likeCount = parseLikeCount(c.like_count);
    const replyData = toReplies(thread);
    const creatorHeart = toCreatorHeart(c);

    return {
      author: authorName,
      authorThumbnails: toThumbnails(author),
      authorId,
      authorUrl,

      isEdited: false, // TODO: Check an edited comment for this.
      isPinned: Boolean(c.is_pinned),
      isSponsor,

      sponsorIconUrl: undefined,

      content: c.content?.text ?? "",
      contentHtml: c.content?.text ?? "",
      published: 0, // TODO: Parse this from publishedText?
      publishedText: c.published_time ?? "",

      likeCount,
      commentId: c.comment_id,
      authorIsChannelOwner: Boolean(c.author_is_channel_owner),

      creatorHeart,
      replies: replyData,
    };
  };

  const comments = commentsResponse.contents
    .filter((t) => t?.comment)
    .map(toInvidiousComment);

  return {
    videoId: id,
    commentCount: Number(commentsResponse.header?.comments_count.text) ??
      comments.length,
    comments,
    // TODO: continuation
    continuation: "NULL",
  };
};

// * CLI

const flags = parseArgs(Deno.args, {
  string: ["port"],
  default: {
    port: 3467,
  }
});

// * Server

Deno.serve({ port: Number(flags.port) }, async (req) => {
  const url = new URL(req.url);
  const searchParams: any = Object.fromEntries(url.searchParams);

  console.log("→", { url: req.url });

  const routes = [
    [
      "/ping",
      () => "pong",
    ],
    [
      "/api/v1/search/suggestions",
      () => getSearchSuggestions(searchParams),
    ],
    [
      "/api/v1/search",
      () => search(searchParams),
    ],
    [
      "/api/v1/channels/(?<channelId>[a-zA-Z0-9_-]+)/videos",
      (params) => getChannelVideos(params.channelId, searchParams),
    ],
    [
      "/api/v1/comments/(?<videoId>[a-zA-Z0-9_-]+)",
      (params) => getVideoComments(params.videoId, searchParams),
    ],
  ];

  let response;
  for (const [pattern, handler] of routes) {
    const match = RegExp(pattern).exec(url.pathname);
    if (match) {
      const result = await handler(match.groups || {});
      if (result) {
        response = result;
        break;
      }
    }
  }

  console.log("←", response ? "OK" : undefined);

  if (response) {
    return typeof response === "string"
      ? new Response(response)
      : new Response(JSON.stringify(response));
  }

  return new Response(`Not found`, { status: 404 });
});

// * Testing

// const val = await search({q: 'iron maiden'})
// console.log(JSON.stringify(val , null, 2))

// const val = await getChannelVideos('UCaisXKBdNOYqGr2qOXCLchQ')
// console.log(JSON.stringify(val , null, 2))
