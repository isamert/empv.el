import { Innertube, UniversalCache, Types as InnerTubeTypes } from 'youtubei.js';

// * InnerTube

const innertube = await Innertube.create({
  cache: new UniversalCache(
    // Enables persistent caching
    true,
    // Path to the cache directory. The directory will be created if it doesn't exist
    './.cache'
  )
});

// * Endpoints

// ** Search Suggestion

// *** Types

export type SearchSuggestionsParams = {
  q: string;
};

export type SearchSuggestionsResponse = {
  query: string;
  suggestions: string[];
};

// *** getSearchSuggestions

const getSearchSuggestions = async (req: SearchSuggestionsParams): Promise<SearchSuggestionsResponse> => {
  const result = await innertube.getSearchSuggestions(req.q)
  return {
    query: req.q,
    suggestions: result,
  }
}

// ** Search

// *** Types

export type SearchParams = {
  q: string;
  // FIXME: Page is utilized
  page?: number;
  sort?: InnerTubeTypes.SortBy;
  date?: InnerTubeTypes.UploadDate;
  duration?: InnerTubeTypes.Duration;
  type?: InnerTubeTypes.SearchType;
  features?: InnerTubeTypes.Feature[];
  // TODO: not supported right now
  region?: string; // ISO 3166 country code
};

export type VideoThumbnail = {
  quality: string;
  url: string;
  width: number;
  height: number;
};

export type AuthorThumbnail = {
  url: string;
  width: number;
  height: number;
};

export type VideoResult = {
  type: 'video';
  title: string;
  videoId: string;
  author: string;
  authorId: string;
  authorUrl: string;
  videoThumbnails: VideoThumbnail[];
  description: string;
  descriptionHtml: string;
  viewCount: number;
  viewCountText: number;
  published: number;
  publishedText: string;
  lengthSeconds: number;
  liveNow: boolean;
  paid: boolean;
  premium: boolean;
};

export type PlaylistVideo = {
  title: string;
  videoId: string;
  lengthSeconds: number;
  videoThumbnails: VideoThumbnail[];
};

export type PlaylistResult = {
  type: 'playlist';
  title: string;
  playlistId: string;
  playlistThumbnail: string;
  author: string;
  authorId: string;
  authorUrl: string;
  authorVerified: boolean;
  videoCount: number;
  videos: PlaylistVideo[];
};

export type ChannelResult = {
  type: 'channel';
  author: string;
  authorId: string;
  authorUrl: string;
  authorThumbnails: AuthorThumbnail[];
  autoGenerated: boolean;
  subCount: number;
  videoCount: number;
  description: string;
  descriptionHtml: string;
};

export type HashtagResult = {
  type: 'hashtag';
  title: string;
  url: string;
  channelCount: number;
  videoCount: number;
};

export type SearchResult =
  | VideoResult
  | PlaylistResult
  | ChannelResult
  | HashtagResult;

export type SearchResponse = SearchResult[];

// *** search result mapper (mostly generated by claude)

/**
 * Converts YouTube search results to the target format
 * @param {unknown} result - The YouTube search result object
 * @returns {Array<{type: string, [key: string]: unknown}>} Converted results
 */
function convertYouTubeResults(result) {
  if (!result || typeof result !== 'object' || !('results' in result)) {
    return [];
  }

  const results = result.results;
  if (!Array.isArray(results)) {
    return [];
  }

  return results.map(item => {
    if (!item || typeof item !== 'object' || !('type' in item)) {
      return null;
    }

    switch (item.type) {
      case 'Video':
        return convertVideo(item);
      case 'Playlist':
        return convertPlaylist(item);
      case 'Channel':
        return convertChannel(item);
      case 'Hashtag':
        return convertHashtag(item);
      default:
        return null;
    }
  }).filter(item => item !== null);
}

/**
 * Converts a video item
 * @param {Record<string, unknown>} item
 * @returns {{type: string, [key: string]: unknown}}
 */
function convertVideo(item) {
  const title = getText(item.title);
  const videoId = typeof item.video_id === 'string' ? item.video_id : '';

  const author = item.author && typeof item.author === 'object'
    ? (typeof item.author.name === 'string' ? item.author.name : '')
    : '';

  const authorId = item.author && typeof item.author === 'object'
    ? (typeof item.author.id === 'string' ? item.author.id : '')
    : '';

  const authorUrl = item.author && typeof item.author === 'object'
    ? (typeof item.author.url === 'string' ? item.author.url : '')
    : '';

  const videoThumbnails = convertThumbnails(item.thumbnails);

  const description = getSnippetText(item.snippets);
  const descriptionHtml = getSnippetHtml(item.snippets);

  const viewCount = parseViewCount(item.view_count);
  const viewCountText = getText(item.view_count);

  const published = 0; // Not available in timestamp format
  const publishedText = getText(item.published);

  const lengthSeconds = parseLengthSeconds(item.length_text);

  const liveNow = false; // Could check badges for LIVE badge
  const paid = false;
  const premium = false;

  return {
    type: 'video',
    title,
    videoId,
    author,
    authorId,
    authorUrl,
    videoThumbnails,
    description,
    descriptionHtml,
    viewCount,
    viewCountText,
    published,
    publishedText,
    lengthSeconds,
    liveNow,
    paid,
    premium
  };
}

/**
 * Converts a playlist item
 * @param {Record<string, unknown>} item
 * @returns {{type: string, [key: string]: unknown}}
 */
function convertPlaylist(item) {
  const title = getText(item.title);
  const playlistId = typeof item.playlist_id === 'string' ? item.playlist_id : '';

  const thumbnails = Array.isArray(item.thumbnails) && item.thumbnails.length > 0
    ? item.thumbnails[0]
    : null;
  const playlistThumbnail = thumbnails && typeof thumbnails === 'object' && 'url' in thumbnails
    ? ensureHttps(typeof thumbnails.url === 'string' ? thumbnails.url : '')
    : '';

  const author = item.author && typeof item.author === 'object'
    ? (typeof item.author.name === 'string' ? item.author.name : '')
    : '';

  const authorId = item.author && typeof item.author === 'object'
    ? (typeof item.author.id === 'string' ? item.author.id : '')
    : '';

  const authorUrl = item.author && typeof item.author === 'object'
    ? (typeof item.author.url === 'string' ? item.author.url : '')
    : '';

  const authorVerified = item.author && typeof item.author === 'object' && 'is_verified' in item.author
    ? Boolean(item.author.is_verified || item.author.is_verified_artist)
    : false;

  const videoCount = typeof item.video_count === 'number' ? item.video_count : 0;

  const videos = Array.isArray(item.videos)
    ? item.videos.map(convertPlaylistVideo).filter(v => v !== null)
    : [];

  return {
    type: 'playlist',
    title,
    playlistId,
    playlistThumbnail,
    author,
    authorId,
    authorUrl,
    authorVerified,
    videoCount,
    videos
  };
}

/**
 * Converts a playlist video item
 * @param {unknown} video
 * @returns {{title: string, videoId: string, lengthSeconds: number, videoThumbnails: Array<{quality: string, url: string, width: number, height: number}>} | null}
 */
function convertPlaylistVideo(video) {
  if (!video || typeof video !== 'object') {
    return null;
  }

  const title = 'title' in video ? getText(video.title) : '';
  const videoId = 'video_id' in video && typeof video.video_id === 'string' ? video.video_id : '';
  const lengthSeconds = 'length_text' in video ? parseLengthSeconds(video.length_text) : 0;
  const videoThumbnails = 'thumbnails' in video ? convertThumbnails(video.thumbnails) : [];

  return {
    title,
    videoId,
    lengthSeconds,
    videoThumbnails
  };
}

/**
 * Converts a channel item
 * @param {Record<string, unknown>} item
 * @returns {{type: string, [key: string]: unknown}}
 */
function convertChannel(item) {
  const author = item.author && typeof item.author === 'object'
    ? (typeof item.author.name === 'string' ? item.author.name : '')
    : '';

  const authorId = typeof item.id === 'string' ? item.id : '';

  const authorUrl = item.author && typeof item.author === 'object'
    ? (typeof item.author.url === 'string' ? item.author.url : '')
    : '';

  const authorThumbnails = item.author && typeof item.author === 'object' && 'thumbnails' in item.author
    ? convertThumbnails(item.author.thumbnails)
    : [];

  const autoGenerated = false;

  const subCount = parseSubscriberCount(item.video_count);

  const videoCount = 0; // subscriber_count field seems misnamed in source

  const description = getText(item.description_snippet);
  const descriptionHtml = getTextAsHtml(item.description_snippet);

  return {
    type: 'channel',
    author,
    authorId,
    authorUrl,
    authorThumbnails,
    autoGenerated,
    subCount,
    videoCount,
    description,
    descriptionHtml
  };
}

/**
 * Converts a hashtag item
 * @param {Record<string, unknown>} item
 * @returns {{type: string, [key: string]: unknown}}
 */
function convertHashtag(item) {
  const title = getText(item.title);
  const url = typeof item.url === 'string' ? item.url : '';
  const channelCount = typeof item.channel_count === 'number' ? item.channel_count : 0;
  const videoCount = typeof item.video_count === 'number' ? item.video_count : 0;

  return {
    type: 'hashtag',
    title,
    url,
    channelCount,
    videoCount
  };
}

/**
 * Extracts text from a text object
 * @param {unknown} textObj
 * @returns {string}
 */
function getText(textObj) {
  if (!textObj || typeof textObj !== 'object') {
    return '';
  }

  if ('text' in textObj && typeof textObj.text === 'string') {
    return textObj.text;
  }

  return '';
}

/**
 * Gets snippet text
 * @param {unknown} snippets
 * @returns {string}
 */
function getSnippetText(snippets) {
  if (!Array.isArray(snippets) || snippets.length === 0) {
    return '';
  }

  const firstSnippet = snippets[0];
  if (!firstSnippet || typeof firstSnippet !== 'object' || !('text' in firstSnippet)) {
    return '';
  }

  return getText(firstSnippet.text);
}

/**
 * Gets snippet HTML
 * @param {unknown} snippets
 * @returns {string}
 */
function getSnippetHtml(snippets) {
  if (!Array.isArray(snippets) || snippets.length === 0) {
    return '';
  }

  const firstSnippet = snippets[0];
  if (!firstSnippet || typeof firstSnippet !== 'object' || !('text' in firstSnippet)) {
    return '';
  }

  return getTextAsHtml(firstSnippet.text);
}

/**
 * Converts text object to HTML
 * @param {unknown} textObj
 * @returns {string}
 */
function getTextAsHtml(textObj) {
  if (!textObj || typeof textObj !== 'object' || !('runs' in textObj)) {
    return getText(textObj);
  }

  const runs = textObj.runs;
  if (!Array.isArray(runs)) {
    return getText(textObj);
  }

  return runs.map(run => {
    if (!run || typeof run !== 'object' || !('text' in run) || typeof run.text !== 'string') {
      return '';
    }

    let html = run.text;

    if ('bold' in run && run.bold === true) {
      html = `<b>${html}</b>`;
    }

    return html;
  }).join('');
}

/**
 * Converts thumbnails array
 * @param {unknown} thumbnails
 * @returns {Array<{quality: string, url: string, width: number, height: number}>}
 */
function convertThumbnails(thumbnails) {
  if (!Array.isArray(thumbnails)) {
    return [];
  }

  return thumbnails.map((thumb, index) => {
    if (!thumb || typeof thumb !== 'object') {
      return null;
    }

    const url = 'url' in thumb && typeof thumb.url === 'string'
      ? ensureHttps(thumb.url)
      : '';
    const width = 'width' in thumb && typeof thumb.width === 'number' ? thumb.width : 0;
    const height = 'height' in thumb && typeof thumb.height === 'number' ? thumb.height : 0;

    const quality = getQualityFromDimensions(width, height, index);

    return { quality, url, width, height };
  }).filter(thumb => thumb !== null);
}

/**
 * Gets quality string from dimensions
 * @param {number} width
 * @param {number} height
 * @param {number} index
 * @returns {string}
 */
function getQualityFromDimensions(width, height, index) {
  if (height >= 720 || width >= 1280) return 'high';
  if (height >= 360 || width >= 640) return 'medium';
  if (height >= 180 || width >= 320) return 'low';
  return `thumbnail${index}`;
}

/**
 * Ensures URL has https protocol
 * @param {string} url
 * @returns {string}
 */
function ensureHttps(url) {
  if (url.startsWith('//')) {
    return `https:${url}`;
  }
  return url;
}

/**
 * Parses view count from text
 * @param {unknown} viewCountObj
 * @returns {number}
 */
function parseViewCount(viewCountObj) {
  const text = getText(viewCountObj);
  if (!text) return 0;

  const match = text.match(/[\d,]+/);
  if (!match) return 0;

  return parseInt(match[0].replace(/,/g, ''), 10) || 0;
}

/**
 * Parses subscriber count from text
 * @param {unknown} subCountObj
 * @returns {number}
 */
function parseSubscriberCount(subCountObj) {
  const text = getText(subCountObj);
  if (!text) return 0;

  const match = text.match(/([\d.]+)([KMB]?)/i);
  if (!match) return 0;

  const num = parseFloat(match[1]);
  const multiplier = match[2].toUpperCase();

  switch (multiplier) {
    case 'K': return Math.floor(num * 1000);
    case 'M': return Math.floor(num * 1000000);
    case 'B': return Math.floor(num * 1000000000);
    default: return Math.floor(num);
  }
}

/**
 * Parses length in seconds from time string
 * @param {unknown} lengthObj
 * @returns {number}
 */
function parseLengthSeconds(lengthObj) {
  const text = getText(lengthObj);
  if (!text) return 0;

  const parts = text.split(':').map(p => parseInt(p, 10));
  if (parts.some(isNaN)) return 0;

  if (parts.length === 2) {
    return parts[0] * 60 + parts[1];
  } else if (parts.length === 3) {
    return parts[0] * 3600 + parts[1] * 60 + parts[2];
  }

  return 0;
}

// *** search

const search = async (req: SearchParams): Promise<SearchResponse> => {
  const result = await innertube.search(req.q, {
    upload_date: req.date,
    type: req.type,
    duration: req.duration,
    sort_by: req.sort,
    features: req.features,
  });

  result.getContinuationData()

  return convertYouTubeResults(result);
}

// * Server

Deno.serve({ port: 3534 }, async (req) => {
  const url = new URL(req.url);
  const searchParams: any = Object.fromEntries(url.searchParams);

  let result;
  if (url.pathname === "/api/v1/search/suggestions") {
    result = await getSearchSuggestions(searchParams)
  } else if (url.pathname === "/api/v1/search") {
    result = await search(searchParams)
  }

  if (result) {
    return new Response(JSON.stringify(result))
  }
  return new Response(`Not found`, { status: 404 });
});

// * Testing

// const val = await search({q: 'iron maiden'})
// console.log(JSON.stringify(val , null, 2))
